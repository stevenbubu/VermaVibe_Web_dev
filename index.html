<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Ver 0.0.2</title>

    <style>
      :root {
        --bar-h: 56px; /* top bar 高度（不含 safe-area） */
        --bar-bg: rgba(0, 0, 0, 0.55);
        --bar-border: rgba(255, 255, 255, 0.12);
        --bar-text: rgba(255, 255, 255, 0.94);

        --btn-bg: rgba(255, 255, 255, 0.06);
        --btn-bg-hover: rgba(255, 255, 255, 0.1);
        --btn-border: rgba(255, 255, 255, 0.12);

        --panel-bg: rgba(0, 0, 0, 0.78);
        --panel-card: rgba(18, 18, 18, 0.92);
        --panel-border: rgba(255, 255, 255, 0.12);

        --accent: #00d4ff;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        overscroll-behavior: contain;
      }

      /* ===== Top Bar ===== */
      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 30;
        padding-top: env(safe-area-inset-top);
        background: var(--bar-bg);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--bar-border);
        box-sizing: border-box;
      }

      .topbar-inner {
        height: var(--bar-h);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 10px;
        box-sizing: border-box;
        gap: 10px;
      }

      .brand {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        color: var(--bar-text);
        font: 650 14px/1 system-ui, "Microsoft JhengHei", sans-serif;
        letter-spacing: 0.3px;
        user-select: none;
        white-space: nowrap;
        min-width: 120px;
      }

      .brand-badge {
        width: 28px;
        height: 28px;
        border-radius: 12px;
        background: rgba(0, 212, 255, 0.14);
        border: 1px solid rgba(0, 212, 255, 0.25);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 18px rgba(0, 212, 255, 0.18);
      }

      .brand-badge svg {
        width: 16px;
        height: 16px;
        color: var(--accent);
      }

      .brand .muted {
        color: rgba(255, 255, 255, 0.68);
        font-weight: 600;
      }

      .actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: nowrap;
      }

      /* icon + 文字按鈕（同一顆） */
      .tool-btn {
        height: 38px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 0 10px;
        border-radius: 12px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: rgba(255, 255, 255, 0.92);
        cursor: pointer;
        transition: transform 0.08s ease, background 0.2s ease,
          border-color 0.2s ease;
        touch-action: manipulation;
        font: 600 12.5px/1 system-ui, "Microsoft JhengHei", sans-serif;
        letter-spacing: 0.2px;
        white-space: nowrap;
      }

      .tool-btn:hover {
        background: var(--btn-bg-hover);
      }

      .tool-btn:active {
        transform: scale(0.985);
      }

      .tool-btn svg {
        width: 18px;
        height: 18px;
        display: block;
        opacity: 0.95;
      }

      /* 螢幕很窄時文字縮小但仍保留 */
      @media (max-width: 380px) {
        .tool-btn {
          font-size: 12px;
          padding: 0 8px;
          gap: 6px;
        }
      }

      /* ===== Stage (下移，避免被 Top Bar 遮住) ===== */
      .stage {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;

        /* topbar + safe-area */
        top: calc(var(--bar-h) + env(safe-area-inset-top));
        height: calc(100dvh - var(--bar-h) - env(safe-area-inset-top));

        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        background: #000;
        overflow: hidden;
        touch-action: pan-y;
        z-index: 10;
      }

      .slide {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        background: #000;
        will-change: transform;
        transform-origin: 0 0;
        touch-action: pan-y;
        backface-visibility: hidden;
      }

      /* ===== Overlay Panel ===== */
      .overlay {
        position: fixed;
        inset: 0;
        background: var(--panel-bg);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 40;
        padding: 18px;
        padding-top: calc(18px + env(safe-area-inset-top));
        padding-bottom: calc(18px + env(safe-area-inset-bottom));
        box-sizing: border-box;
      }
      .overlay.show {
        display: flex;
      }

      .panel {
        width: min(560px, 100%);
        background: var(--panel-card);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        overflow: hidden;
      }

      .panel-hd {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 14px 12px;
        border-bottom: 1px solid var(--panel-border);
        gap: 12px;
      }

      .panel-title {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #fff;
        font: 750 15px/1.2 system-ui, "Microsoft JhengHei", sans-serif;
      }

      .panel-title svg {
        width: 18px;
        height: 18px;
        opacity: 0.95;
      }

      .close-btn {
        width: 36px;
        height: 36px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
        color: #fff;
        cursor: pointer;
      }

      .panel-bd {
        padding: 14px;
        color: rgba(255, 255, 255, 0.86);
        font: 14px/1.7 system-ui, "Microsoft JhengHei", sans-serif;
      }

      .panel-bd a {
        color: #7fe7ff;
        text-decoration: none;
      }
      .panel-bd a:hover {
        text-decoration: underline;
      }

      .muted {
        color: rgba(255, 255, 255, 0.68);
      }
    </style>
  </head>

  <body>
    <!-- ===== Top Bar ===== -->
    <header class="topbar" id="topbar">
      <div class="topbar-inner">
        <div class="brand" title="VermaVibe Viewer">
          <span class="brand-badge" aria-hidden="true">
            <!-- Brand icon (wave/vibe) -->
            <svg viewBox="0 0 24 24" fill="none">
              <path
                d="M4 13c2-6 4 6 6 0s4-6 6 0 4-6 4-6"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </span>
          <span>VermaVibe</span>
          <span class="muted">｜Viewer</span>
        </div>

        <nav class="actions" aria-label="Top actions" id="toolbar">
          <!-- 關於 -->
          <button
            class="tool-btn"
            type="button"
            data-panel="about"
            aria-label="關於"
          >
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="M12 10.7v6.2"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              />
              <path
                d="M12 7.6h.01"
                stroke="currentColor"
                stroke-width="2.6"
                stroke-linecap="round"
              />
            </svg>
            <span>關於</span>
          </button>

          <!-- 技術 -->
          <button
            class="tool-btn"
            type="button"
            data-panel="tech"
            aria-label="技術"
          >
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M9 18 3 12l6-6"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M15 6l6 6-6 6"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M13.5 5.5 10.5 18.5"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              />
            </svg>
            <span>技術</span>
          </button>

          <!-- 案例 -->
          <button
            class="tool-btn"
            type="button"
            data-panel="cases"
            aria-label="案例"
          >
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M7 7.5A2.5 2.5 0 0 1 9.5 5h9A2.5 2.5 0 0 1 21 7.5v9A2.5 2.5 0 0 1 18.5 19h-9A2.5 2.5 0 0 1 7 16.5v-9Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="M3 9.2A2.2 2.2 0 0 1 5.2 7H7v12H5.2A2.2 2.2 0 0 1 3 16.8V9.2Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="M10 10.2h8M10 13h8M10 15.8h5.5"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              />
            </svg>
            <span>案例</span>
          </button>

          <!-- 聯絡 -->
          <button
            class="tool-btn"
            type="button"
            data-panel="contact"
            aria-label="聯絡"
          >
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M4 7.5A2.5 2.5 0 0 1 6.5 5h11A2.5 2.5 0 0 1 20 7.5v9A2.5 2.5 0 0 1 17.5 19h-11A2.5 2.5 0 0 1 4 16.5v-9Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="m5.5 7.2 6.1 5a1 1 0 0 0 1.3 0l6.1-5"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <span>聯絡</span>
          </button>
        </nav>
      </div>
    </header>

    <!-- ===== Stage ===== -->
    <div class="stage" id="stage">
      <img id="viewer" class="slide" src="" alt="slide" draggable="false" />
    </div>

    <!-- ===== Overlay Panel ===== -->
    <div
      class="overlay"
      id="overlay"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
    >
      <div class="panel" role="document">
        <div class="panel-hd">
          <div class="panel-title">
            <span id="panelIcon" aria-hidden="true"></span>
            <span id="panelText">標題</span>
          </div>
          <button
            class="close-btn"
            id="btnClose"
            type="button"
            aria-label="關閉"
          >
            ✕
          </button>
        </div>
        <div class="panel-bd" id="panelBody">內容</div>
      </div>
    </div>

    <script>
      // ======================
      //  Config
      // ======================
      const COUNT = 12;
      const FOLDER = "images/VermaVibe_20251217";
      const images = Array.from(
        { length: COUNT },
        (_, i) => `${FOLDER}/${i + 1}.PNG`
      );

      const MIN_SCALE = 1,
        MAX_SCALE = 6;
      const DOUBLE_TAP_MS = 300;
      const DOUBLE_TAP_TARGET_SCALE = 2.5;
      const ZOOM_ANIM_MS = 220;
      const WHEEL_ZOOM_FACTOR = 1.1;

      const EPS = 0.2;
      const isTouchDevice = navigator.maxTouchPoints > 0;

      const CLICK_THRESHOLD_PX = isTouchDevice ? 22 : 10;
      const CLICK_THRESHOLD_PY = isTouchDevice ? 22 : 10;
      const TAP_DURATION_MS = 250;

      const SWIPE_MIN_PX = isTouchDevice ? 48 : 36;
      const SWIPE_MIN_VELOCITY = 0.35;

      const INERTIA_MIN_SPEED = 0.02;
      const INERTIA_FRICTION = 0.5;
      const BOUNCE_COEFF = 0.1;
      const PAN_HISTORY_MS = 120;

      // ======================
      //  DOM
      // ======================
      const viewer = document.getElementById("viewer");
      const stage = document.getElementById("stage");

      // overlay
      const overlay = document.getElementById("overlay");
      const panelIcon = document.getElementById("panelIcon");
      const panelText = document.getElementById("panelText");
      const panelBody = document.getElementById("panelBody");
      const btnClose = document.getElementById("btnClose");
      const toolbar = document.getElementById("toolbar");

      // ======================
      //  State
      // ======================
      let idx = 0;
      let scale = 1;
      let tx = 0,
        ty = 0;
      let rafId = null;

      // viewport
      let viewportW = 0,
        viewportH = 0;

      // base contain size & center offset
      let baseW = 0,
        baseH = 0;
      let baseLx = 0,
        baseLy = 0;

      // pointers
      const pointers = new Map();
      let dragStart = null;
      let stageDragStart = null;

      // tap/swipe tracking
      let tapStartX = null,
        tapStartY = null,
        tapStartTime = 0;
      let lastMoveX = null,
        lastMoveY = null,
        lastMoveTime = 0;

      // anti-jump recompute
      let recomputeTimer = null;
      let viewportDirty = false;

      // inertia
      let panAnimId = null;
      let panHistory = [];

      // zoom animation
      let zoomAnimId = null;

      // double tap time
      let lastTap = 0;

      // ✅ single tap delayed (avoid double tap switching)
      let tapTimer = null;

      // ======================
      //  Utils
      // ======================
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      const nowMs = () => performance.now();

      const isOverlayOpen = () => overlay.classList.contains("show");

      function cancelSingleTap() {
        if (tapTimer) {
          clearTimeout(tapTimer);
          tapTimer = null;
        }
      }
      function scheduleSingleTap(clientX) {
        cancelSingleTap();
        tapTimer = setTimeout(() => {
          tapTimer = null;
          handlePositionalClick(clientX);
        }, DOUBLE_TAP_MS + 30);
      }

      function stopPanInertia() {
        if (panAnimId) cancelAnimationFrame(panAnimId);
        panAnimId = null;
      }
      function stopZoomAnim() {
        if (zoomAnimId) cancelAnimationFrame(zoomAnimId);
        zoomAnimId = null;
      }

      function updateViewport() {
        const vv = window.visualViewport;
        if (vv && vv.width && vv.height) {
          viewportW = vv.width;
          viewportH = vv.height;
        } else {
          const r = stage.getBoundingClientRect();
          viewportW = r.width;
          viewportH = r.height;
        }
      }

      function computeContain(nw, nh) {
        const imgRatio = nw / nh;
        const stageRatio = viewportW / viewportH;
        if (imgRatio > stageRatio)
          return { w: viewportW, h: viewportW / imgRatio };
        return { h: viewportH, w: viewportH * imgRatio };
      }

      function computeBaseTopLeft() {
        baseLx = (viewportW - baseW) / 2;
        baseLy = (viewportH - baseH) / 2;
      }

      function clientToImagePoint(clientX, clientY) {
        const ix = (clientX - baseLx - tx) / scale;
        const iy = (clientY - baseLy - ty) / scale;
        return { x: clamp(ix, 0, baseW), y: clamp(iy, 0, baseH) };
      }

      // ✅ zoomed-content bounds (and lock-to-center if content <= viewport)
      function getPanBounds() {
        const contentW = baseW * scale;
        const contentH = baseH * scale;

        let minTx, maxTx, minTy, maxTy;

        if (contentW > viewportW) {
          minTx = viewportW - baseLx - contentW - EPS;
          maxTx = -baseLx + EPS;
        } else {
          const txCenter = (-baseW * (scale - 1)) / 2;
          minTx = maxTx = txCenter;
        }

        if (contentH > viewportH) {
          minTy = viewportH - baseLy - contentH - EPS;
          maxTy = -baseLy + EPS;
        } else {
          const tyCenter = (-baseH * (scale - 1)) / 2;
          minTy = maxTy = tyCenter;
        }

        return { minTx, maxTx, minTy, maxTy };
      }

      function commit(needsClamp = true) {
        if (needsClamp) {
          const { minTx, maxTx, minTy, maxTy } = getPanBounds();
          tx = clamp(tx, minTx, maxTx);
          ty = clamp(ty, minTy, maxTy);
        }
        if (rafId) return;
        rafId = requestAnimationFrame(() => {
          viewer.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${scale})`;
          setInteractionMode();
          rafId = null;
        });
      }

      function setInteractionMode() {
        const ta = scale === 1 ? "pan-y" : "none";
        viewer.style.touchAction = ta;
        stage.style.touchAction = ta;
      }

      function preventNativeIfZooming(e) {
        if (scale > 1) e.preventDefault?.();
      }

      function recomputeBaseSize() {
        updateViewport();
        const nw = viewer.naturalWidth || viewer.width || viewer.offsetWidth;
        const nh = viewer.naturalHeight || viewer.height || viewer.offsetHeight;
        if (!nw || !nh || !viewportW || !viewportH) return;

        const s = computeContain(nw, nh);
        baseW = s.w;
        baseH = s.h;

        // make rendering consistent for math
        viewer.style.width = `${baseW}px`;
        viewer.style.height = `${baseH}px`;

        computeBaseTopLeft();
        commit(true);
      }

      function isInteracting() {
        return (
          pointers.size > 0 ||
          !!stageDragStart ||
          scale > 1 ||
          !!panAnimId ||
          !!zoomAnimId
        );
      }

      function scheduleRecompute(delay = 320) {
        clearTimeout(recomputeTimer);
        if (isInteracting()) {
          viewportDirty = true;
          return;
        }
        viewportDirty = false;
        recomputeTimer = setTimeout(recomputeBaseSize, delay);
      }

      function tryRecomputeAfterInteraction() {
        if (viewportDirty && !isInteracting()) scheduleRecompute(160);
      }

      // ======================
      //  Slides
      // ======================
      function show(i) {
        stopPanInertia();
        stopZoomAnim();
        cancelSingleTap();

        idx = (i + images.length) % images.length;
        scale = 1;
        tx = 0;
        ty = 0;

        const url = images[idx];
        viewer.src = url;
        viewer.alt = `slide ${idx + 1}`;

        viewer.onload = () => {
          const waitNatural = () => {
            if (!viewer.naturalWidth || !viewer.naturalHeight) {
              requestAnimationFrame(waitNatural);
              return;
            }
            recomputeBaseSize();
          };
          waitNatural();
        };

        viewer.onerror = () => {
          // 你也可在這裡做 toast
          console.warn("Load failed:", url);
        };

        // preload next
        const pre = new Image();
        pre.decoding = "async";
        pre.src = images[(idx + 1) % images.length];
      }

      function handlePositionalClick(clientX) {
        if (scale !== 1) return;
        const leftHalf = clientX < viewportW / 2;
        show(leftHalf ? idx - 1 : idx + 1);
      }

      // ======================
      //  Zoom (centered)
      // ======================
      function zoomAtPoint(targetScale, clientX, clientY) {
        const s1 = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        const p = clientToImagePoint(clientX, clientY);
        tx = clientX - baseLx - p.x * s1;
        ty = clientY - baseLy - p.y * s1;
        scale = s1;
        commit(true);
      }

      function zoomAtCenter(targetScale) {
        updateViewport();
        zoomAtPoint(targetScale, viewportW / 2, viewportH / 2);
      }

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function animateZoomAtCenter(targetScale, duration = ZOOM_ANIM_MS) {
        stopZoomAnim();
        updateViewport();

        const startScale = scale;
        const cX = viewportW / 2,
          cY = viewportH / 2;
        const p = clientToImagePoint(cX, cY);
        const sTarget = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        const t0 = nowMs();

        const step = () => {
          const dt = Math.min(1, (nowMs() - t0) / duration);
          const s = startScale + (sTarget - startScale) * easeOutCubic(dt);

          tx = cX - baseLx - p.x * s;
          ty = cY - baseLy - p.y * s;
          scale = s;

          commit(true);

          if (dt < 1) zoomAnimId = requestAnimationFrame(step);
          else {
            stopZoomAnim();
            commit(true);
          }
        };
        step();
      }

      // ======================
      //  Inertia
      // ======================
      function recordPanHistory(px, py) {
        const t = nowMs();
        panHistory.push({ x: px, y: py, t });
        const cutoff = t - PAN_HISTORY_MS;
        while (panHistory.length && panHistory[0].t < cutoff)
          panHistory.shift();
      }

      function computePanVelocity() {
        if (panHistory.length < 2) return { vx: 0, vy: 0 };
        const a = panHistory[0],
          b = panHistory[panHistory.length - 1];
        const dt = Math.max(1, b.t - a.t);
        return { vx: (b.x - a.x) / dt, vy: (b.y - a.y) / dt };
      }

      function startPanInertia(vx, vy) {
        stopPanInertia();
        let lastTs = nowMs();

        const step = () => {
          const ts = nowMs();
          const dt = Math.max(1, ts - lastTs);
          lastTs = ts;

          // decay
          const decay = Math.pow(INERTIA_FRICTION, dt / 16);
          vx *= decay;
          vy *= decay;

          // update
          tx += vx * dt;
          ty += vy * dt;

          // bounce
          const { minTx, maxTx, minTy, maxTy } = getPanBounds();
          if (tx < minTx && vx < 0) {
            tx = minTx;
            vx *= -BOUNCE_COEFF;
          }
          if (tx > maxTx && vx > 0) {
            tx = maxTx;
            vx *= -BOUNCE_COEFF;
          }
          if (ty < minTy && vy < 0) {
            ty = minTy;
            vy *= -BOUNCE_COEFF;
          }
          if (ty > maxTy && vy > 0) {
            ty = maxTy;
            vy *= -BOUNCE_COEFF;
          }

          commit(false);

          const small =
            Math.abs(vx) < INERTIA_MIN_SPEED &&
            Math.abs(vy) < INERTIA_MIN_SPEED;
          const inside =
            tx >= minTx && tx <= maxTx && ty >= minTy && ty <= maxTy;

          if (small && inside) {
            stopPanInertia();
            commit(true);
            return;
          }
          panAnimId = requestAnimationFrame(step);
        };

        panAnimId = requestAnimationFrame(step);
      }

      // ======================
      //  Overlay (Panels)
      // ======================
      // Extract icons from toolbar buttons so panel title can reuse
      function getButtonIconHTML(type) {
        const btn = toolbar.querySelector(`[data-panel="${type}"]`);
        return btn ? btn.querySelector("svg")?.outerHTML || "" : "";
      }

      const PANEL_CONTENT = {
        about: {
          title: "關於",
          body: `
            <div>這是一個圖片簡報 Viewer（手機單擊換頁、雙擊放大、縮放後拖曳與慣性）。</div>
            <div class="muted" style="margin-top:8px;">可在此放專案介紹、作者資訊或版本說明。</div>
          `,
        },
        tech: {
          title: "技術",
          body: `
            <div>目前支援：</div>
            <ul style="margin:8px 0 0 18px;">
              <li>Contain 置中顯示 + 100dvh + safe-area</li>
              <li>手機：單擊換頁（延遲判斷）、雙擊只縮放</li>
              <li>縮放後拖曳、慣性滑動、邊界反彈</li>
              <li>桌機：← → / Space / Home / End；Ctrl+滾輪縮放</li>
            </ul>
          `,
        },
        cases: {
          title: "案例",
          body: `
            <div>你可以在此放案例列表（例如連到不同資料夾或專案頁）：</div>
            <ul style="margin:8px 0 0 18px;">
              <li>#案例 A：品牌視覺</a></li>
              <li>#案例 B：UI Mock</a></li>
              <li>#案例 C：海報系列</a></li>
            </ul>
            <div class="muted" style="margin-top:8px;">（之後可把點擊改成切換不同 FOLDER 或開新頁）</div>
          `,
        },
        contact: {
          title: "聯絡",
          body: `
            <div>聯絡方式：</div>
            <ul style="margin:8px 0 0 18px;">
              <li>Email：mailto:someone@example.comsomeone@example.com</a></li>
              <li>網站：https://example.comhttps://example.com</a></li>
              <li>社群：IG / FB / LinkedIn</li>
            </ul>
            <div class="muted" style="margin-top:8px;">（請把資料換成你的實際資訊）</div>
          `,
        },
      };

      function openPanel(type) {
        cancelSingleTap();
        stopPanInertia();

        const cfg = PANEL_CONTENT[type];
        if (!cfg) return;

        panelIcon.innerHTML = getButtonIconHTML(type);
        panelText.textContent = cfg.title;
        panelBody.innerHTML = cfg.body;

        overlay.classList.add("show");
        overlay.setAttribute("aria-hidden", "false");
        setTimeout(() => btnClose.focus?.(), 0);
      }

      function closePanel() {
        overlay.classList.remove("show");
        overlay.setAttribute("aria-hidden", "true");
      }

      // toolbar event delegation
      toolbar.addEventListener("click", (e) => {
        const btn = e.target.closest("[data-panel]");
        if (!btn) return;
        e.stopPropagation();
        openPanel(btn.dataset.panel);
      });

      btnClose.addEventListener("click", closePanel);
      overlay.addEventListener("click", (e) => {
        if (e.target === overlay) closePanel();
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && isOverlayOpen()) {
          e.preventDefault();
          closePanel();
        }
      });

      // ======================
      //  Pointer interactions
      // ======================
      viewer.addEventListener(
        "pointerdown",
        (e) => {
          if (isOverlayOpen()) return;

          stopPanInertia();
          pointers.set(e.pointerId, {
            x: e.clientX,
            y: e.clientY,
            type: e.pointerType,
          });

          // capture (more stable drag)
          try {
            viewer.setPointerCapture(e.pointerId);
          } catch {}

          // ✅ touch double tap: zoom only (cancel single-tap switch)
          const tNow = nowMs();
          if (e.pointerType === "touch" && tNow - lastTap < DOUBLE_TAP_MS) {
            cancelSingleTap();
            animateZoomAtCenter(scale > 1 ? 1 : DOUBLE_TAP_TARGET_SCALE);
            lastTap = 0;
            e.preventDefault?.();
            e.stopPropagation?.();
            return;
          }
          lastTap = e.pointerType === "touch" ? tNow : 0;

          // start drag only when zoomed
          if (scale > 1) {
            dragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty };
            panHistory.length = 0;
            recordPanHistory(e.clientX, e.clientY);
          }
        },
        { passive: false }
      );

      viewer.addEventListener(
        "pointermove",
        (e) => {
          if (isOverlayOpen()) return;
          if (!pointers.has(e.pointerId)) return;

          preventNativeIfZooming(e);
          pointers.set(e.pointerId, {
            x: e.clientX,
            y: e.clientY,
            type: e.pointerType,
          });

          if (scale > 1 && dragStart) {
            tx = dragStart.tx0 + (e.clientX - dragStart.x);
            ty = dragStart.ty0 + (e.clientY - dragStart.y);
            recordPanHistory(e.clientX, e.clientY);
            commit(true);
          }
        },
        { passive: false }
      );

      viewer.addEventListener("pointerup", (e) => {
        pointers.delete(e.pointerId);
        try {
          viewer.releasePointerCapture(e.pointerId);
        } catch {}

        // inertia if zoomed & dragged
        if (scale > 1 && dragStart) {
          const { vx, vy } = computePanVelocity();
          if (
            Math.abs(vx) >= INERTIA_MIN_SPEED ||
            Math.abs(vy) >= INERTIA_MIN_SPEED
          ) {
            startPanInertia(vx, vy);
          }
        }

        dragStart = null;
        setInteractionMode();
        scheduleRecompute();
        tryRecomputeAfterInteraction();
      });

      viewer.addEventListener("pointercancel", () => {
        pointers.clear();
        dragStart = null;
        setInteractionMode();
        scheduleRecompute();
        tryRecomputeAfterInteraction();
      });

      // stage: tap/swipe when scale===1; drag when scale>1
      stage.addEventListener(
        "pointerdown",
        (e) => {
          if (isOverlayOpen()) return;

          stopPanInertia();
          pointers.set(e.pointerId, {
            x: e.clientX,
            y: e.clientY,
            type: e.pointerType,
          });

          if (scale > 1) {
            stageDragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty };
            panHistory.length = 0;
            recordPanHistory(e.clientX, e.clientY);
            try {
              stage.setPointerCapture(e.pointerId);
            } catch {}
            return;
          }

          if (e.buttons && e.buttons !== 1) return;

          tapStartX = e.clientX;
          tapStartY = e.clientY;
          tapStartTime = nowMs();
          lastMoveX = tapStartX;
          lastMoveY = tapStartY;
          lastMoveTime = tapStartTime;
        },
        { passive: false }
      );

      stage.addEventListener(
        "pointermove",
        (e) => {
          if (isOverlayOpen()) return;

          preventNativeIfZooming(e);

          if (scale > 1 && stageDragStart) {
            tx = stageDragStart.tx0 + (e.clientX - stageDragStart.x);
            ty = stageDragStart.ty0 + (e.clientY - stageDragStart.y);
            recordPanHistory(e.clientX, e.clientY);
            commit(true);
            return;
          }

          lastMoveX = e.clientX;
          lastMoveY = e.clientY;
          lastMoveTime = nowMs();
        },
        { passive: false }
      );

      stage.addEventListener("pointerup", (e) => {
        if (isOverlayOpen()) return;

        pointers.delete(e.pointerId);

        if (scale > 1) {
          const { vx, vy } = computePanVelocity();
          if (
            Math.abs(vx) >= INERTIA_MIN_SPEED ||
            Math.abs(vy) >= INERTIA_MIN_SPEED
          ) {
            startPanInertia(vx, vy);
          }
          stageDragStart = null;
          try {
            stage.releasePointerCapture(e.pointerId);
          } catch {}
          scheduleRecompute();
          tryRecomputeAfterInteraction();
          return;
        }

        // scale===1: tap or swipe
        const endX = e.clientX,
          endY = e.clientY;
        const endTime = nowMs();
        const dx = endX - (tapStartX ?? endX);
        const dy = endY - (tapStartY ?? endY);
        const dt = endTime - (tapStartTime || endTime);

        const mvDt = Math.max(1, endTime - (lastMoveTime || endTime));
        const mvDx = endX - (lastMoveX ?? endX);
        const velocityX = Math.abs(mvDx) / mvDt;

        const absDx = Math.abs(dx),
          absDy = Math.abs(dy);

        const isSwipe =
          absDx > SWIPE_MIN_PX &&
          absDx > absDy * 1.5 &&
          velocityX >= SWIPE_MIN_VELOCITY;

        if (isSwipe) {
          cancelSingleTap();
          show(dx < 0 ? idx + 1 : idx - 1);
        } else {
          const isTap =
            absDx <= CLICK_THRESHOLD_PX &&
            absDy <= CLICK_THRESHOLD_PY &&
            dt <= TAP_DURATION_MS;

          if (isTap) {
            // ✅ touch: delayed to see if it becomes double tap
            if (e.pointerType === "touch") scheduleSingleTap(endX);
            else handlePositionalClick(endX);
          }
        }

        tapStartX = tapStartY = null;
        tapStartTime = 0;
        lastMoveX = lastMoveY = null;
        lastMoveTime = 0;
      });

      stage.addEventListener("pointercancel", () => {
        pointers.clear();
        stageDragStart = null;
        tapStartX = tapStartY = null;
        tapStartTime = 0;
        lastMoveX = lastMoveY = null;
        lastMoveTime = 0;
        cancelSingleTap();
        scheduleRecompute();
        tryRecomputeAfterInteraction();
      });

      stage.addEventListener("contextmenu", (e) => e.preventDefault());

      // wheel: ctrl+wheel zoom only
      stage.addEventListener(
        "wheel",
        (e) => {
          if (isOverlayOpen()) return;
          if (e.ctrlKey) {
            e.preventDefault();
            const factor =
              Math.sign(e.deltaY) > 0
                ? 1 / WHEEL_ZOOM_FACTOR
                : WHEEL_ZOOM_FACTOR;
            zoomAtCenter(clamp(scale * factor, MIN_SCALE, MAX_SCALE));
          }
        },
        { passive: false }
      );

      // keyboard
      document.addEventListener("keydown", (e) => {
        if (isOverlayOpen()) return;

        const k = e.key;
        if (k === "ArrowLeft") {
          e.preventDefault();
          show(idx - 1);
        } else if (k === "ArrowRight") {
          e.preventDefault();
          show(idx + 1);
        } else if (k === "Home") {
          e.preventDefault();
          show(0);
        } else if (k === "End") {
          e.preventDefault();
          show(images.length - 1);
        } else if (k === " ") {
          e.preventDefault();
          show(idx + 1);
        } else if (k.toLowerCase() === "r") {
          e.preventDefault();
          scale = 1;
          tx = 0;
          ty = 0;
          commit(true);
        } else if (k === "+" || k === "=") {
          e.preventDefault();
          zoomAtCenter(clamp(scale * WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE));
        } else if (k === "-" || k === "_") {
          e.preventDefault();
          zoomAtCenter(clamp(scale / WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE));
        }
      });

      // viewport changes
      function onViewportChange() {
        viewportDirty = true;
        scheduleRecompute();
      }
      window.addEventListener("resize", onViewportChange);
      window.addEventListener("orientationchange", onViewportChange);
      if (window.visualViewport)
        window.visualViewport.addEventListener("resize", onViewportChange);

      // init
      show(0);
    </script>
  </body>
</html>
``
