<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>ver 0.0.20</title>

    <style>
      :root {
        --bar-h: 56px;
        --bg-0: #0c0f14;
        --bg-1: #0f1320;
        --bg-2: #121a2b;

        --glass-bg: rgba(16, 24, 40, 0.45);
        --glass-border: rgba(255, 255, 255, 0.12);

        --bar-bg: rgba(16, 24, 40, 0.5);
        --bar-border: rgba(255, 255, 255, 0.12);

        --bar-text: rgba(255, 255, 255, 0.92);
        --muted-text: rgba(255, 255, 255, 0.65);

        --btn-bg: rgba(255, 255, 255, 0.06);
        --btn-bg-hover: rgba(255, 255, 255, 0.12);
        --btn-border: rgba(255, 255, 255, 0.16);

        --accent: #00d4ff;
        --accent-soft: rgba(0, 212, 255, 0.2);
        --accent-glow: 0 0 22px rgba(0, 212, 255, 0.32);

        --ring-1: rgba(0, 212, 255, 0.25);
        --ring-2: rgba(166, 129, 255, 0.25);

        --font-ui: system-ui, 'Inter', 'SF Pro Text', 'Microsoft JhengHei', sans-serif;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        background: radial-gradient(
            1200px 600px at 10% 10%,
            var(--bg-2) 0%,
            var(--bg-1) 55%,
            var(--bg-0) 100%
          ),
          linear-gradient(135deg, var(--bg-1), var(--bg-2));
        overscroll-behavior: contain;
        color: var(--bar-text);
        font: 500 14px/1.6 var(--font-ui);
      }

      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 30;
        padding-top: env(safe-area-inset-top);
        background: var(--bar-bg);
        backdrop-filter: blur(14px) saturate(1.2);
        -webkit-backdrop-filter: blur(14px) saturate(1.2);
        border-bottom: 1px solid var(--bar-border);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        box-sizing: border-box;
      }
      .topbar-inner {
        height: var(--bar-h);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        gap: 10px;
      }
      .brand {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        color: var(--bar-text);
        font: 650 14px/1 var(--font-ui);
        letter-spacing: 0.4px;
        user-select: none;
        white-space: nowrap;
        min-width: 0;
      }
      .brand-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .brand-badge .brand-logo {
        height: clamp(28px, calc(var(--bar-h) - 6px), 48px);
        width: auto;
        display: block;
        filter: drop-shadow(0 2px 10px rgba(0, 0, 0, 0.35));
      }
      .brand .muted {
        color: var(--muted-text);
        font-weight: 600;
      }
      .actions {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: nowrap;
      }

      .tool-btn {
        height: 38px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 0 12px;
        border-radius: 12px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--bar-text);
        cursor: pointer;
        transition: transform 0.08s ease, background 0.2s ease, border-color 0.2s ease,
          box-shadow 0.2s ease, color 0.2s ease;
        touch-action: manipulation;
        font: 600 12.5px/1 var(--font-ui);
        letter-spacing: 0.3px;
        white-space: nowrap;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
      }
      .tool-btn:hover {
        background: var(--btn-bg-hover);
        border-color: var(--accent);
        box-shadow: var(--accent-glow);
        color: #eafcff;
      }
      .tool-btn:active {
        transform: scale(0.985);
      }
      .tool-btn svg {
        width: 18px;
        height: 18px;
        display: block;
        opacity: 0.95;
        stroke: var(--bar-text);
        transition: stroke 0.2s ease, filter 0.2s ease;
      }
      .tool-btn:hover svg {
        stroke: var(--accent);
        filter: drop-shadow(0 0 6px rgba(0, 212, 255, 0.6));
      }
      .tool-btn.active {
        border-color: rgba(0, 212, 255, 0.55);
        background: var(--accent-soft);
        box-shadow: var(--accent-glow);
      }

      @media (max-width: 420px) {
        .tool-btn {
          font-size: 12px;
          padding: 0 8px;
          gap: 6px;
        }
      }

      .stage {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        top: calc(var(--bar-h) + env(safe-area-inset-top));
        height: calc(100dvh - var(--bar-h) - env(safe-area-inset-top));
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        overflow: hidden;
        touch-action: pan-y;
        z-index: 10;
        background: radial-gradient(420px 220px at 20% 30%, var(--ring-1), transparent 60%),
          radial-gradient(480px 260px at 80% 70%, var(--ring-2), transparent 65%),
          linear-gradient(135deg, var(--bg-1), var(--bg-2));
      }

      .slide {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        background: transparent;
        will-change: transform;
        transform-origin: 0 0;
        touch-action: pan-y;
        backface-visibility: hidden;
        transition: filter 0.25s ease, opacity 0.26s ease;
      }
      .slide[src] {
        filter: drop-shadow(0 14px 40px rgba(0, 0, 0, 0.45));
      }

      /* Contact 表單容器（在 stage 內） */
      .contact-wrap {
        width: min(720px, 92vw);
        margin: 0 auto;
        padding: 18px 16px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--bar-text);
        border-radius: 16px;
        backdrop-filter: blur(10px) saturate(1.08);
        -webkit-backdrop-filter: blur(10px) saturate(1.08);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35), var(--accent-glow);
      }
      .contact-title {
        font: 700 18px/1.4 var(--font-ui);
        letter-spacing: 0.3px;
        margin: 4px 0 14px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .contact-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px 14px;
      }
      @media (max-width: 640px) {
        .contact-grid {
          grid-template-columns: 1fr;
        }
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .field label {
        font-size: 13px;
        color: var(--muted-text);
        letter-spacing: 0.3px;
      }
      .field input,
      .field select,
      .field textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--btn-border);
        background: rgba(255, 255, 255, 0.06);
        color: var(--bar-text);
        outline: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        font: 500 14px/1.4 var(--font-ui);
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
      }
      .field input::placeholder,
      .field textarea::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }
      .field input:focus,
      .field select:focus,
      .field textarea:focus {
        border-color: var(--accent);
        box-shadow: var(--accent-glow);
        background: rgba(255, 255, 255, 0.12);
      }
      .field textarea {
        min-height: 100px;
        resize: vertical;
      }

      .contact-actions {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 14px;
      }
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--bar-text);
        cursor: pointer;
        transition: transform 0.08s ease, background 0.2s ease, border-color 0.2s ease,
          box-shadow 0.2s ease, color 0.2s ease;
        font: 600 13px/1 var(--font-ui);
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
      }
      .btn:hover {
        background: var(--btn-bg-hover);
        border-color: var(--accent);
        box-shadow: var(--accent-glow);
        color: #eafcff;
      }
      .btn:active {
        transform: scale(0.985);
      }

      .status {
        position: fixed;
        left: 10px;
        bottom: 10px;
        z-index: 50;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--bar-text);
        font: 12.5px/1.6 var(--font-ui);
        max-width: min(560px, calc(100vw - 20px));
        display: none;
        backdrop-filter: blur(10px) saturate(1.1);
        -webkit-backdrop-filter: blur(10px) saturate(1.1);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35), var(--accent-glow);
      }
      .status.show {
        display: block;
      }
      .status .muted {
        color: var(--muted-text);
      }
    </style>
  </head>

  <body>
    <header class="topbar">
      <div class="topbar-inner">
        <div class="brand" title="VermaVibe Viewer">
          <span class="brand-badge" aria-hidden="true">
            <svg
              class="brand-logo"
              xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink"
              viewBox="0 0 136 162"
              preserveAspectRatio="xMidYMid meet"
              aria-hidden="true"
            >
              <g>data:image/png;base64,<!-- 你的 base64 --></g>
            </svg>
          </span>
          <span>VermaVibe</span>
          <span class="muted">｜<span id="albumName">About</span></span>
        </div>

        <nav class="actions" id="toolbar" aria-label="Albums">
          <button class="tool-btn active" type="button" data-album="about">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="M12 10.7v6.2"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              />
              <path
                d="M12 7.6h.01"
                stroke="currentColor"
                stroke-width="2.6"
                stroke-linecap="round"
              />
            </svg>
            <span>About</span>
          </button>

          <button class="tool-btn" type="button" data-album="tech">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M9 18 3 12l6-6"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M15 6l6 6-6 6"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M13.5 5.5 10.5 18.5"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              />
            </svg>
            <span>Tech</span>
          </button>

          <button class="tool-btn" type="button" data-album="cases">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M7 7.5A2.5 2.5 0 0 1 9.5 5h9A2.5 2.5 0 0 1 21 7.5v9A2.5 2.5 0 0 1 18.5 19h-9A2.5 2.5 0 0 1 7 16.5v-9Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="M3 9.2A2.2 2.2 0 0 1 5.2 7H7v12H5.2A2.2 2.2 0 0 1 3 16.8V9.2Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="M10 10.2h8M10 13h8M10 15.8h5.5"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              />
            </svg>
            <span>Case</span>
          </button>

          <button class="tool-btn" type="button" data-album="collab">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M8.2 13.2 6 11l-3 3 3.2 3.2c.7.7 1.8.7 2.5 0l1.2-1.2"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M15.8 13.2 18 11l3 3-3.2 3.2c-.7.7-1.8.7-2.5 0l-1.2-1.2"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M9 14.5l2 2c.6.6 1.4.6 2 0l2-2"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M9.2 10.5 11 8.7c.6-.6 1.4-.6 2 0l1.8 1.8"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <span>Collab</span>
          </button>

          <button class="tool-btn" type="button" data-album="contact">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M4 7.5A2.5 2.5 0 0 1 6.5 5h11A2.5 2.5 0 0 1 20 7.5v9A2.5 2.5 0 0 1 17.5 19h-11A2.5 2.5 0 0 1 4 16.5v-9Z"
                stroke="currentColor"
                stroke-width="1.8"
              />
              <path
                d="m5.5 7.2 6.1 5a1 1 0 0 0 1.3 0l6.1-5"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <span>Contact</span>
          </button>
        </nav>
      </div>
    </header>

    <div class="stage" id="stage">
      <!-- Contact 模式會用 JS 動態插入 .contact-wrap；圖片模式下使用 viewer -->
      <img id="viewer" class="slide" src="" alt="slide" draggable="false" />
    </div>

    <div class="status" id="status"></div>

    <script>
      const CONTACT_EMAIL = 'bubuchacha@outlook.com'

      const ALBUMS = {
        about: {
          label: 'About',
          folder: 'images/About',
          manifest: 'manifest.json',
          count: 12,
          ext: 'PNG',
          pad: 0,
          type: 'images',
        },
        tech: {
          label: 'Tech',
          folder: 'images/Tech',
          manifest: 'manifest.json',
          count: 18,
          ext: 'PNG',
          pad: 0,
          type: 'images',
        },
        cases: {
          label: 'Case',
          folder: 'images/Cases',
          manifest: 'manifest.json',
          count: 20,
          ext: 'PNG',
          pad: 0,
          type: 'images',
        },
        collab: {
          label: 'Collab',
          folder: 'images/Collab',
          manifest: 'manifest.json',
          count: 10,
          ext: 'PNG',
          pad: 0,
          type: 'images',
        },
        contact: {
          label: 'Contact',
          folder: '',
          manifest: '',
          count: 0,
          ext: '',
          pad: 0,
          type: 'form',
        },
      }

      const MIN_SCALE = 1,
        MAX_SCALE = 6
      const DOUBLE_TAP_MS = 300
      const DOUBLE_TAP_TARGET_SCALE = 2.5
      const ZOOM_ANIM_MS = 220
      const WHEEL_ZOOM_FACTOR = 1.1
      const EPS = 0.2
      const isTouchDevice = navigator.maxTouchPoints > 0

      const CLICK_THRESHOLD_PX = isTouchDevice ? 22 : 10
      const CLICK_THRESHOLD_PY = isTouchDevice ? 22 : 10
      const TAP_DURATION_MS = 250
      const SWIPE_MIN_PX = isTouchDevice ? 48 : 36
      const SWIPE_MIN_VELOCITY = 0.35
      const INERTIA_MIN_SPEED = 0.02
      const INERTIA_FRICTION = 0.5
      const BOUNCE_COEFF = 0.1
      const PAN_HISTORY_MS = 120

      const viewer = document.getElementById('viewer')
      const stage = document.getElementById('stage')
      const toolbar = document.getElementById('toolbar')
      const albumName = document.getElementById('albumName')
      const statusEl = document.getElementById('status')

      let currentAlbumKey = 'about'
      let images = []

      let idx = 0
      let scale = 1
      let tx = 0,
        ty = 0
      let rafId = null

      let viewportW = 0,
        viewportH = 0
      let baseW = 0,
        baseH = 0
      let baseLx = 0,
        baseLy = 0

      const pointers = new Map()
      let dragStart = null
      let stageDragStart = null

      let tapStartX = null,
        tapStartY = null,
        tapStartTime = 0
      let lastMoveX = null,
        lastMoveY = null,
        lastMoveTime = 0

      let recomputeTimer = null
      let viewportDirty = false
      let panAnimId = null
      let panHistory = []
      let zoomAnimId = null
      let lastTap = 0
      let tapTimer = null

      function setStatus(msg, keep = false) {
        if (!msg) {
          statusEl.classList.remove('show')
          statusEl.textContent = ''
          return
        }
        statusEl.innerHTML = msg
        statusEl.classList.add('show')
        if (!keep) {
          clearTimeout(setStatus._t)
          setStatus._t = setTimeout(() => setStatus(''), 2200)
        }
      }

      const clamp = (v, min, max) => Math.min(max, Math.max(min, v))
      const nowMs = () => performance.now()

      function cancelSingleTap() {
        if (tapTimer) {
          clearTimeout(tapTimer)
          tapTimer = null
        }
      }
      function scheduleSingleTap(clientX) {
        cancelSingleTap()
        tapTimer = setTimeout(() => {
          tapTimer = null
          handlePositionalClick(clientX)
        }, DOUBLE_TAP_MS + 30)
      }

      function stopPanInertia() {
        if (panAnimId) cancelAnimationFrame(panAnimId)
        panAnimId = null
      }
      function stopZoomAnim() {
        if (zoomAnimId) cancelAnimationFrame(zoomAnimId)
        zoomAnimId = null
      }

      function updateViewport() {
        const vv = window.visualViewport
        if (vv && vv.width && vv.height) {
          viewportW = vv.width
          viewportH = vv.height
        } else {
          const r = stage.getBoundingClientRect()
          viewportW = r.width
          viewportH = r.height
        }
      }

      function computeContain(nw, nh) {
        const imgRatio = nw / nh,
          stageRatio = viewportW / viewportH
        if (imgRatio > stageRatio) return { w: viewportW, h: viewportW / imgRatio }
        return { h: viewportH, w: viewportH * imgRatio }
      }

      function computeBaseTopLeft() {
        baseLx = (viewportW - baseW) / 2
        baseLy = (viewportH - baseH) / 2
      }

      function clientToImagePoint(clientX, clientY) {
        const ix = (clientX - baseLx - tx) / scale,
          iy = (clientY - baseLy - ty) / scale
        return { x: clamp(ix, 0, baseW), y: clamp(iy, 0, baseH) }
      }

      function getPanBounds() {
        const contentW = baseW * scale,
          contentH = baseH * scale
        let minTx, maxTx, minTy, maxTy
        if (contentW > viewportW) {
          minTx = viewportW - baseLx - contentW - EPS
          maxTx = -baseLx + EPS
        } else {
          const txCenter = (-baseW * (scale - 1)) / 2
          minTx = maxTx = txCenter
        }
        if (contentH > viewportH) {
          minTy = viewportH - baseLy - contentH - EPS
          maxTy = -baseLy + EPS
        } else {
          const tyCenter = (-baseH * (scale - 1)) / 2
          minTy = maxTy = tyCenter
        }
        return { minTx, maxTx, minTy, maxTy }
      }

      function commit(needsClamp = true) {
        if (needsClamp) {
          const { minTx, maxTx, minTy, maxTy } = getPanBounds()
          tx = clamp(tx, minTx, maxTx)
          ty = clamp(ty, minTy, maxTy)
        }
        if (rafId) return
        rafId = requestAnimationFrame(() => {
          viewer.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${scale})`
          setInteractionMode()
          rafId = null
        })
      }

      function setInteractionMode() {
        const ta = scale === 1 ? 'pan-y' : 'none'
        viewer.style.touchAction = ta
        stage.style.touchAction = ta
      }

      function preventNativeIfZooming(e) {
        if (scale > 1) e.preventDefault?.()
      }

      function recomputeBaseSize() {
        updateViewport()
        const nw = viewer.naturalWidth || viewer.width || viewer.offsetWidth
        const nh = viewer.naturalHeight || viewer.height || viewer.offsetHeight
        if (!nw || !nh || !viewportW || !viewportH) return
        const s = computeContain(nw, nh)
        baseW = s.w
        baseH = s.h
        viewer.style.width = `${baseW}px`
        viewer.style.height = `${baseH}px`
        computeBaseTopLeft()
        commit(true)
      }

      function isInteracting() {
        return pointers.size > 0 || !!stageDragStart || scale > 1 || !!panAnimId || !!zoomAnimId
      }
      function scheduleRecompute(delay = 320) {
        clearTimeout(recomputeTimer)
        if (isInteracting()) {
          viewportDirty = true
          return
        }
        viewportDirty = false
        recomputeTimer = setTimeout(recomputeBaseSize, delay)
      }
      function tryRecomputeAfterInteraction() {
        if (viewportDirty && !isInteracting()) scheduleRecompute(160)
      }

      function padNumber(n, pad) {
        if (!pad) return String(n)
        return String(n).padStart(pad, '0')
      }
      function buildFallbackList(album) {
        const { folder, count, ext, pad = 0 } = album
        return Array.from({ length: count }, (_, i) => `${folder}/${padNumber(i + 1, pad)}.${ext}`)
      }

      function canFetchManifest() {
        return location.protocol === 'http:' || location.protocol === 'https:'
      }

      async function loadAlbumList(key) {
        const album = ALBUMS[key]
        if (!album) throw new Error('Unknown album: ' + key)
        if (album.type === 'form') return [] // 表單不載入圖片
        if (album.manifest && canFetchManifest()) {
          const url = `${album.folder}/${album.manifest}?v=${Date.now()}`
          try {
            const res = await fetch(url, { cache: 'no-store' })
            if (res.ok) {
              const data = await res.json()
              const files = Array.isArray(data)
                ? data
                : data && Array.isArray(data.files)
                ? data.files
                : null
              if (files && files.length) return files.map((name) => `${album.folder}/${name}`)
            } else {
              setStatus(`manifest 讀取失敗（HTTP ${res.status}），改用 fallback`, false)
            }
          } catch {
            setStatus(`manifest fetch 失敗，改用 fallback`, false)
          }
        } else if (album.manifest && !canFetchManifest()) {
          setStatus(
            `目前是 file:// 開啟，跳過 manifest，使用 count fallback（建議用本機伺服器）`,
            false
          )
        }
        return buildFallbackList(album)
      }

      function clearStageExtras() {
        // 移除可能存在的 contact-wrap
        const exist = stage.querySelector('.contact-wrap')
        if (exist) exist.remove()
        // 顯示 viewer
        viewer.style.display = ''
      }

      async function setAlbum(key) {
        if (!ALBUMS[key]) return
        toolbar
          .querySelectorAll('.tool-btn')
          .forEach((btn) => btn.classList.toggle('active', btn.dataset.album === key))

        currentAlbumKey = key
        albumName.textContent = ALBUMS[key].label

        stopPanInertia()
        stopZoomAnim()
        cancelSingleTap()
        scale = 1
        tx = 0
        ty = 0
        commit(true)

        if (ALBUMS[key].type === 'form') {
          images = []
          renderContactForm() // 表單模式
          return
        }

        clearStageExtras()
        images = await loadAlbumList(key)
        show(0)
      }

      // ---- Contact 表單 ----
      function renderContactForm() {
        // 隱藏 viewer（避免疊在表單後面）
        viewer.style.display = 'none'

        // 建立容器
        const wrap = document.createElement('div')
        wrap.className = 'contact-wrap'
        wrap.innerHTML = `
        <div class="contact-title">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M4 7.5A2.5 2.5 0 0 1 6.5 5h11A2.5 2.5 0 0 1 20 7.5v9A2.5 2.5 0 0 1 17.5 19h-11A2.5 2.5 0 0 1 4 16.5v-9Z" stroke="currentColor" stroke-width="1.8"/>
            <path d="m5.5 7.2 6.1 5a1 1 0 0 0 1.3 0l6.1-5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span>聯絡我們</span>
        </div>
        <form id="contactForm" novalidate>
          <div class="contact-grid">
            <div class="field">
              <label for="name">姓名 *</label>
              <input id="name" name="name" type="text" placeholder="王小明" required />
            </div>
            <div class="field">
              <label for="email">Email *</label>
              <input id="email" name="email" type="email" placeholder="you@example.com" required />
            </div>
            <div class="field">
              <label for="phone">電話</label>
              <input id="phone" name="phone" type="tel" placeholder="0912-345-678" />
            </div>
            <div class="field">
              <label for="topic">主題 *</label>
              <select id="topic" name="topic" required>
                <option value="">請選擇</option>
                <option>一般詢問</option>
                <option>技術合作</option>
                <option>專案諮詢</option>
                <option>媒體與公關</option>
              </select>
            </div>
            <div class="field" style="grid-column: 1 / -1;">
              <label for="message">訊息 *</label>
              <textarea id="message" name="message" placeholder="請簡述您的需求或問題" required></textarea>
            </div>
          </div>
          <div class="contact-actions">
            <button type="submit" class="btn" id="sendBtn">送出</button>
            <button type="reset" class="btn">清除</button>
          </div>
          <div style="margin-top:8px; color: var(--muted-text); font-size:12px;">
            送出後將以您的預設郵件程式寄出（純前端模式）。若您需要 API 直傳，告訴我您的伺服器端點即可加上。
          </div>
        </form>
      `
        stage.appendChild(wrap)

        const form = wrap.querySelector('#contactForm')
        form.addEventListener('submit', (e) => {
          e.preventDefault()
          const name = form.name.value.trim()
          const email = form.email.value.trim()
          const phone = form.phone.value.trim()
          const topic = form.topic.value.trim()
          const message = form.message.value.trim()

          // 基本驗證
          const errors = []
          if (!name) errors.push('請填寫姓名')
          if (!email || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) errors.push('Email 格式不正確')
          if (!topic) errors.push('請選擇主題')
          if (!message) errors.push('請填寫訊息')
          if (errors.length) {
            setStatus(`<b>表單錯誤：</b> ${errors.join('、')}`)
            return
          }

          // 組合 mailto（避免特殊字元斷行，使用 encodeURIComponent）
          const subject = encodeURIComponent(`【${topic}】${name} 的聯絡需求`)
          const bodyLines = [
            `姓名：${name}`,
            `Email：${email}`,
            `電話：${phone || '-'}`,
            `主題：${topic}`,
            '',
            '訊息：',
            message,
            '',
            '---',
            '來源：VermaVibe Viewer（Contact 表單）',
          ]
          const body = encodeURIComponent(bodyLines.join('\n'))

          const mailto = `mailto:${CONTACT_EMAIL}?subject=${subject}&body=${body}`
          window.location.href = mailto

          setStatus(`已開啟郵件程式，準備寄送給 <span class="muted">${CONTACT_EMAIL}</span>`)
        })
      }

      // ---- 圖片 Slides ----
      function show(i) {
        stopPanInertia()
        stopZoomAnim()
        cancelSingleTap()
        if (!images.length) return

        idx = (i + images.length) % images.length
        scale = 1
        tx = 0
        ty = 0

        const url = images[idx]

        viewer.style.opacity = '0'
        viewer.style.transition = 'opacity 260ms ease'

        viewer.src = url
        viewer.alt = `slide ${idx + 1}`

        viewer.onload = () => {
          const waitNatural = () => {
            if (!viewer.naturalWidth || !viewer.naturalHeight) {
              requestAnimationFrame(waitNatural)
              return
            }
            recomputeBaseSize()
            requestAnimationFrame(() => {
              viewer.style.opacity = '1'
            })
          }
          waitNatural()
        }
        viewer.onerror = () => {
          setStatus(`圖片載入失敗：<span class="muted">${url}</span>`, true)
          viewer.style.opacity = '1'
        }

        const pre = new Image()
        pre.decoding = 'async'
        pre.src = images[(idx + 1) % images.length]
      }

      function handlePositionalClick(clientX) {
        if (scale !== 1) return
        const leftHalf = clientX < viewportW / 2
        show(leftHalf ? idx - 1 : idx + 1)
      }

      function zoomAtPoint(targetScale, clientX, clientY) {
        const s1 = clamp(targetScale, MIN_SCALE, MAX_SCALE)
        const p = clientToImagePoint(clientX, clientY)
        tx = clientX - baseLx - p.x * s1
        ty = clientY - baseLy - p.y * s1
        scale = s1
        commit(true)
      }
      function zoomAtCenter(targetScale) {
        updateViewport()
        zoomAtPoint(targetScale, viewportW / 2, viewportH / 2)
      }
      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3)
      }

      function animateZoomAtCenter(targetScale, duration = ZOOM_ANIM_MS) {
        stopZoomAnim()
        updateViewport()
        const startScale = scale,
          cX = viewportW / 2,
          cY = viewportH / 2
        const p = clientToImagePoint(cX, cY)
        const sTarget = clamp(targetScale, MIN_SCALE, MAX_SCALE)
        const t0 = nowMs()

        const step = () => {
          const dt = Math.min(1, (nowMs() - t0) / duration)
          const s = startScale + (sTarget - startScale) * easeOutCubic(dt)
          tx = cX - baseLx - p.x * s
          ty = cY - baseLy - p.y * s
          scale = s
          commit(true)
          if (dt < 1) zoomAnimId = requestAnimationFrame(step)
          else {
            stopZoomAnim()
            commit(true)
          }
        }
        step()
      }

      function recordPanHistory(px, py) {
        const t = nowMs()
        panHistory.push({ x: px, y: py, t })
        const cutoff = t - PAN_HISTORY_MS
        while (panHistory.length && panHistory[0].t < cutoff) panHistory.shift()
      }
      function computePanVelocity() {
        if (panHistory.length < 2) return { vx: 0, vy: 0 }
        const a = panHistory[0],
          b = panHistory[panHistory.length - 1]
        const dt = Math.max(1, b.t - a.t)
        return { vx: (b.x - a.x) / dt, vy: (b.y - a.y) / dt }
      }
      function startPanInertia(vx, vy) {
        stopPanInertia()
        let lastTs = nowMs()
        const step = () => {
          const ts = nowMs()
          const dt = Math.max(1, ts - lastTs)
          lastTs = ts
          const decay = Math.pow(INERTIA_FRICTION, dt / 16)
          vx *= decay
          vy *= decay
          tx += vx * dt
          ty += vy * dt
          const { minTx, maxTx, minTy, maxTy } = getPanBounds()
          if (tx < minTx && vx < 0) {
            tx = minTx
            vx *= -BOUNCE_COEFF
          }
          if (tx > maxTx && vx > 0) {
            tx = maxTx
            vx *= -BOUNCE_COEFF
          }
          if (ty < minTy && vy < 0) {
            ty = minTy
            vy *= -BOUNCE_COEFF
          }
          if (ty > maxTy && vy > 0) {
            ty = maxTy
            vy *= -BOUNCE_COEFF
          }
          commit(false)
          const small = Math.abs(vx) < INERTIA_MIN_SPEED && Math.abs(vy) < INERTIA_MIN_SPEED
          const inside = tx >= minTx && tx <= maxTx && ty >= minTy && ty <= maxTy
          if (small && inside) {
            stopPanInertia()
            commit(true)
            return
          }
          panAnimId = requestAnimationFrame(step)
        }
        panAnimId = requestAnimationFrame(step)
      }

      toolbar.addEventListener('click', async (e) => {
        const btn = e.target.closest('[data-album]')
        if (!btn) return
        e.stopPropagation()
        await setAlbum(btn.dataset.album)
      })

      viewer.addEventListener(
        'pointerdown',
        (e) => {
          stopPanInertia()
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: e.pointerType })
          try {
            viewer.setPointerCapture(e.pointerId)
          } catch {}

          const tNow = nowMs()
          if (e.pointerType === 'touch' && tNow - lastTap < DOUBLE_TAP_MS) {
            cancelSingleTap()
            animateZoomAtCenter(scale > 1 ? 1 : DOUBLE_TAP_TARGET_SCALE)
            lastTap = 0
            e.preventDefault?.()
            e.stopPropagation?.()
            return
          }
          lastTap = e.pointerType === 'touch' ? tNow : 0

          if (scale > 1) {
            dragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty }
            panHistory.length = 0
            recordPanHistory(e.clientX, e.clientY)
          }
        },
        { passive: false }
      )

      viewer.addEventListener(
        'pointermove',
        (e) => {
          if (!pointers.has(e.pointerId)) return
          preventNativeIfZooming(e)
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: e.pointerType })
          if (scale > 1 && dragStart) {
            tx = dragStart.tx0 + (e.clientX - dragStart.x)
            ty = dragStart.ty0 + (e.clientY - dragStart.y)
            recordPanHistory(e.clientX, e.clientY)
            commit(true)
          }
        },
        { passive: false }
      )

      viewer.addEventListener('pointerup', (e) => {
        pointers.delete(e.pointerId)
        try {
          viewer.releasePointerCapture(e.pointerId)
        } catch {}
        if (scale > 1 && dragStart) {
          const { vx, vy } = computePanVelocity()
          if (Math.abs(vx) >= INERTIA_MIN_SPEED || Math.abs(vy) >= INERTIA_MIN_SPEED)
            startPanInertia(vx, vy)
        }
        dragStart = null
        setInteractionMode()
        scheduleRecompute()
        tryRecomputeAfterInteraction()
      })

      viewer.addEventListener('pointercancel', () => {
        pointers.clear()
        dragStart = null
        setInteractionMode()
        scheduleRecompute()
        tryRecomputeAfterInteraction()
      })

      stage.addEventListener(
        'pointerdown',
        (e) => {
          stopPanInertia()
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: e.pointerType })
          if (scale > 1) {
            stageDragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty }
            panHistory.length = 0
            recordPanHistory(e.clientX, e.clientY)
            try {
              stage.setPointerCapture(e.pointerId)
            } catch {}
            return
          }
          if (e.buttons && e.buttons !== 1) return
          tapStartX = e.clientX
          tapStartY = e.clientY
          tapStartTime = nowMs()
          lastMoveX = tapStartX
          lastMoveY = tapStartY
          lastMoveTime = tapStartTime
        },
        { passive: false }
      )

      stage.addEventListener(
        'pointermove',
        (e) => {
          preventNativeIfZooming(e)
          if (scale > 1 && stageDragStart) {
            tx = stageDragStart.tx0 + (e.clientX - stageDragStart.x)
            ty = stageDragStart.ty0 + (e.clientY - stageDragStart.y)
            recordPanHistory(e.clientX, e.clientY)
            commit(true)
            return
          }
          lastMoveX = e.clientX
          lastMoveY = e.clientY
          lastMoveTime = nowMs()
        },
        { passive: false }
      )

      stage.addEventListener('pointerup', (e) => {
        pointers.delete(e.pointerId)
        if (scale > 1) {
          const { vx, vy } = computePanVelocity()
          if (Math.abs(vx) >= INERTIA_MIN_SPEED || Math.abs(vy) >= INERTIA_MIN_SPEED)
            startPanInertia(vx, vy)
          stageDragStart = null
          try {
            stage.releasePointerCapture(e.pointerId)
          } catch {}
          scheduleRecompute()
          tryRecomputeAfterInteraction()
          return
        }
        const endX = e.clientX,
          endY = e.clientY,
          endTime = nowMs()
        const dx = endX - (tapStartX ?? endX),
          dy = endY - (tapStartY ?? endY)
        const dt = endTime - (tapStartTime || endTime)
        const mvDt = Math.max(1, endTime - (lastMoveTime || endTime))
        const mvDx = endX - (lastMoveX ?? endX),
          velocityX = Math.abs(mvDx) / mvDt
        const absDx = Math.abs(dx),
          absDy = Math.abs(dy)
        const isSwipe =
          absDx > SWIPE_MIN_PX && absDx > absDy * 1.5 && velocityX >= SWIPE_MIN_VELOCITY
        if (isSwipe) {
          cancelSingleTap()
          show(dx < 0 ? idx + 1 : idx - 1)
        } else {
          const isTap =
            absDx <= CLICK_THRESHOLD_PX && absDy <= CLICK_THRESHOLD_PY && dt <= TAP_DURATION_MS
          if (isTap) {
            if (e.pointerType === 'touch') scheduleSingleTap(endX)
            else handlePositionalClick(endX)
          }
        }
        tapStartX = tapStartY = null
        tapStartTime = 0
        lastMoveX = lastMoveY = null
        lastMoveTime = 0
      })

      stage.addEventListener('pointercancel', () => {
        pointers.clear()
        stageDragStart = null
        tapStartX = tapStartY = null
        tapStartTime = 0
        lastMoveX = lastMoveY = null
        lastMoveTime = 0
        cancelSingleTap()
        scheduleRecompute()
        tryRecomputeAfterInteraction()
      })

      stage.addEventListener('contextmenu', (e) => e.preventDefault())

      stage.addEventListener(
        'wheel',
        (e) => {
          if (e.ctrlKey) {
            e.preventDefault()
            const factor = Math.sign(e.deltaY) > 0 ? 1 / WHEEL_ZOOM_FACTOR : WHEEL_ZOOM_FACTOR
            zoomAtCenter(clamp(scale * factor, MIN_SCALE, MAX_SCALE))
          }
        },
        { passive: false }
      )

      document.addEventListener('keydown', (e) => {
        const k = e.key
        if (k === 'ArrowLeft') {
          e.preventDefault()
          show(idx - 1)
        } else if (k === 'ArrowRight') {
          e.preventDefault()
          show(idx + 1)
        } else if (k === 'Home') {
          e.preventDefault()
          show(0)
        } else if (k === 'End') {
          e.preventDefault()
          show(images.length - 1)
        } else if (k === ' ') {
          e.preventDefault()
          show(idx + 1)
        } else if (k.toLowerCase() === 'r') {
          e.preventDefault()
          scale = 1
          tx = 0
          ty = 0
          commit(true)
        } else if (k === '+' || k === '=') {
          e.preventDefault()
          zoomAtCenter(clamp(scale * WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE))
        } else if (k === '-' || k === '_') {
          e.preventDefault()
          zoomAtCenter(clamp(scale / WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE))
        }
      })

      function onViewportChange() {
        viewportDirty = true
        scheduleRecompute()
      }
      window.addEventListener('resize', onViewportChange)
      window.addEventListener('orientationchange', onViewportChange)
      if (window.visualViewport) window.visualViewport.addEventListener('resize', onViewportChange)
      ;(async function init() {
        await setAlbum(currentAlbumKey)
      })()
    </script>
  </body>
</html>
